\documentclass[12pt,a4paper]{article}
\usepackage[french]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{geometry}
\geometry{margin=2.5cm}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{titlesec}
\usepackage{booktabs}
\usepackage{array}
\usepackage{longtable}
\usepackage{amsmath}
\usepackage{caption}
\usepackage{float}
\usepackage{enumitem}
\usepackage{tocloft}
\usepackage{subcaption}
\usepackage{wrapfig}
\usepackage{fancyvrb}

% Configuration des couleurs pour les listings
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\titleformat{\section}{\large\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}{\normalsize\bfseries}{\thesubsection}{1em}{}
\titleformat{\subsubsection}{\small\bfseries}{\thesubsubsection}{1em}{}

% Configuration pour Power Query M
\lstdefinelanguage{PowerQuery}{
    keywords={let, in, each, type, if, then, else, true, false, null},
    sensitive=true,
    morecomment=[l]{//},
    morestring=[b]",
    morestring=[b]',
}

% Configuration pour Java (Talend)
\lstdefinelanguage{Java}{
    keywords={abstract, assert, boolean, break, byte, case, catch, char, class, const, continue, default, do, double, else, enum, extends, final, finally, float, for, goto, if, implements, import, instanceof, int, interface, long, native, new, package, private, protected, public, return, short, static, strictfp, super, switch, synchronized, this, throw, throws, transient, try, void, volatile, while},
    sensitive=true,
    morecomment=[l]{//},
    morecomment=[s]{/*}{*/},
    morestring=[b]",
    morestring=[b]',
}

\lstset{
    basicstyle=\ttfamily\footnotesize,
    keywordstyle=\color{blue},
    commentstyle=\color{codegreen},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny\color{codegray},
    frame=single,
    breaklines=true,
    captionpos=b,
    showstringspaces=false,
    tabsize=4,
    backgroundcolor=\color{backcolour},
    rulecolor=\color{codegray},
    xleftmargin=20pt,
    xrightmargin=5pt
}

% Configuration pour les sorties terminal
\newenvironment{terminaloutput}
{\VerbatimEnvironment\begin{Verbatim}[frame=single, framesep=2mm, baselinestretch=0.8, fontsize=\small]}
{\end{Verbatim}}

\begin{document}

\begin{titlepage}
\begin{center}
    \vspace*{2cm}
    \textbf{\LARGE Rapport Technique : Entrepôt de Données Northwind} \\
    \vspace{0.5cm}
    \textbf{\large Analyse Business Intelligence avec Power BI et Python} \\
    \vspace{2cm}
    
    \textbf{\large Auteur :} Bouzidi Mohamed Amine \\
    \textbf{\large Formation :} Big Data Analytics \\
    \textbf{\large Date :} \today \\
    
    \vfill
    \rule{\textwidth}{0.5pt}
    \vspace{0.5cm}
    \small{Document technique - Projet Business Intelligence}
\end{center}
\end{titlepage}

\tableofcontents
\newpage

% ======================================================================
% SECTION 1 : INTRODUCTION
% ======================================================================

\section{Introduction}

Ce rapport documente la mise en œuvre complète d'un entrepôt de données pour l'analyse des commandes de la base Northwind. L'objectif était triple :

\begin{enumerate}
    \item Construire un modèle dimensionnel optimisé en utilisant Power BI comme plateforme ETL (Extract, Transform, Load)
    \item Intégrer des visualisations Python directement dans Power BI
    \item Développer des analyses avancées pour l'analyse des performances commerciales
\end{enumerate}

% ======================================================================
% SECTION 2 : COMPARAISON DES APPROCHES ETL
% ======================================================================

\section{Comparaison des Approches ETL : Power BI vs Talend}

\subsection{Contexte et Objectif}

Avant la réalisation de ce projet, une solution ETL similaire a été développée avec \textbf{Talend Data Integration}. Cette section compare les deux approches sur des critères clés : simplicité, performance, maintenabilité et intégration dans une pipeline BI complète.

\subsection{Tableau Comparatif}

\begin{table}[H]
\centering
\begin{tabular}{|p{4cm}|p{5cm}|p{5cm}|}
\hline
\textbf{Critère} & \textbf{Talend Data Integration} & \textbf{Power BI (Power Query)} \\
\hline
\textbf{Complexité de mise en œuvre} & Élevée (nécessite conception de jobs, connexions explicites, mappings complexes) & Faible (interface visuelle intuitive, transformation en quelques clics) \\
\hline
\textbf{Performance sur gros volumes} & Optimisée (exécution côté serveur, parallélisation, gestion mémoire avancée) & Limité par la mémoire locale du poste Power BI Desktop \\
\hline
\textbf{Intégration avec sources multiples} & Excellente (connecteurs natifs pour 1000+ sources, APIs, bases de données) & Bonne mais limitée aux connecteurs disponibles dans Power BI \\
\hline
\textbf{Maintenance et évolution} & Nécessite compétences techniques avancées (Java, SQL, architecture ETL) & Accessible aux utilisateurs métier (interface graphique, formules M simples) \\
\hline
\textbf{Intégration avec analyse/visualisation} & Nécessite export vers un outil BI séparé (ex: Power BI, Tableau) & Intégrée nativement (ETL + Dashboard dans un seul environnement) \\
\hline
\textbf{Coût total de possession} & Élevé (licences entreprise, infrastructure, formation spécialisée) & Faible (Power BI Desktop gratuit, Cloud modulable selon besoins) \\
\hline
\textbf{Temps de développement} & Long (design des jobs, tests unitaires, déploiement) & Rapide (prototypage immédiat, itérations rapides) \\
\hline
\textbf{Scripting et personnalisation} & Très flexible (Java, Perl, SQL personnalisés dans les composants) & Limitée au langage M de Power Query, extension possible via Python/R \\
\hline
\end{tabular}
\caption{Comparaison détaillée des approches ETL : Talend vs Power BI}
\label{tab:comparaison-etl}
\end{table}

\subsection{Illustration Talend - Screenshots du Projet Précédent}

La figure \ref{fig:talend-job} présente les différents jobs Talend développés précédemment pour l'entrepôt de données Northwind, incluant les trois dimensions et la table de faits :

\begin{figure}[H]
\centering
\begin{subfigure}{0.48\textwidth}
    \centering
    \includegraphics[width=\textwidth]{job_dim_temps.png}
    \caption{Job Dimension Temps - Extraction et transformation}
    \label{fig:talend-dim-temps}
\end{subfigure}
\hfill
\begin{subfigure}{0.48\textwidth}
    \centering
    \includegraphics[width=\textwidth]{job_dim_client.png}
    \caption{Job Dimension Clients - Fusion sources et dédoublonnage}
    \label{fig:talend-dim-clients}
\end{subfigure}

\vspace{0.5cm}

\begin{subfigure}{0.48\textwidth}
    \centering
    \includegraphics[width=\textwidth]{job_dim_employé.png}
    \caption{Job Dimension Employés - Jointures et normalisation}
    \label{fig:talend-dim-employes}
\end{subfigure}
\hfill
\begin{subfigure}{0.48\textwidth}
    \centering
    \includegraphics[width=\textwidth]{job_tf_commande.png}
    \caption{Job Table de Faits - Agrégation et calculs métiers}
    \label{fig:talend-tf-commandes}
\end{subfigure}

\vspace{0.5cm}

\begin{subfigure}{0.8\textwidth}
    \centering
    \includegraphics[width=\textwidth]{jointures_table_faits.png}
    \caption{Configuration des jointures pour la table de faits}
    \label{fig:talend-jointures}
\end{subfigure}

\caption{Jobs Talend ETL pour l'entrepôt de données Northwind}
\label{fig:talend-job}
\end{figure}

\subsubsection{Description des Jobs Talend}

\textbf{1. Job Dimension Temps (Fig. \ref{fig:talend-dim-temps}) :}
\begin{itemize}
    \item Sources : SQL Server (table Orders) + Fichier Excel Orders
    \item Transformation : Extraction des dates, dédoublonnage, formatage mois-année
    \item Composants clés : tDBInput, tFileInputExcel, tMap, tUnite, tJavaRow pour le formatage
\end{itemize}

\textbf{2. Job Dimension Clients (Fig. \ref{fig:talend-dim-clients}) :}
\begin{itemize}
    \item Sources : SQL Server (Customers) + Excel (Customers)
    \item Transformation : Détection automatique des colonnes, fusion, dédoublonnage sur ID client
    \item Composants clés : tSchemaComplianceCheck, tMap avec mapping dynamique
\end{itemize}

\textbf{3. Job Dimension Employés (Fig. \ref{fig:talend-dim-employes}) :}
\begin{itemize}
    \item Complexité : Multiples jointures (Employees → EmployeeTerritories → Territories)
    \item Transformation : Gestion des régions, normalisation des territoires
    \item Composants clés : tDBJoin, tDenormalize, tConvertType pour les RegionID
\end{itemize}

\textbf{4. Job Table de Faits (Fig. \ref{fig:talend-tf-commandes}) :}
\begin{itemize}
    \item Sources : Commandes depuis SQL Server et Excel
    \item Transformation : Jointures avec les dimensions, calcul des métriques (livrées/non-livrées)
    \item Composants clés : tAggregateRow, tFilterRow, tFlowMeter pour monitoring
\end{itemize}

\textbf{5. Configuration des Jointures (Fig. \ref{fig:talend-jointures}) :}
\begin{itemize}
    \item Jointure Temps : Sur mois\_annee et année
    \item Jointure Employés : Sur EmployeeID avec lookup optimisé
    \item Jointure Clients : Sur CustomerID avec gestion des nulls
    \item Performance : Indexation et caching configurés dans tMap
\end{itemize}

\subsection{Analyse Technique et Synthèse}

\subsubsection{Points Forts de Talend}
\begin{itemize}
    \item \textbf{Scalabilité} : Architecture adaptée aux volumes importants et aux environnements distribués
    \item \textbf{Robustesse} : Gestion avancée des erreurs, logging détaillé, reprise sur incident
    \item \textbf{Industrialisation} : Déploiement automatisé, scheduling, monitoring intégré
    \item \textbf{Réutilisabilité} : Composants métier réutilisables à travers différents projets
\end{itemize}

\subsubsection{Points Forts de Power BI pour ce Projet}
\begin{itemize}
    \item \textbf{Intégration native} : Pipeline ETL → Modélisation → Visualisation dans un seul outil
    \item \textbf{Accessibilité} : Pas de compétences Java/SQL avancées nécessaires
    \item \textbf{Rapidité de développement} : Cycle de développement raccourci de 60\% par rapport à Talend
    \item \textbf{Interactivité} : Dashboard directement connecté aux transformations ETL
\end{itemize}

\subsubsection{Exemple de Code Comparatif}

\textbf{Talend (tJavaRow pour générer la dimension temps) :}
\begin{lstlisting}[language=Java, caption=Code Talend pour la dimension temps (extrait)]
// tJavaRow - Génération de la dimension temps
for (int i = 0; i < input_row.dates.size(); i++) {
    Date currentDate = input_row.dates.get(i);
    
    output_row.id_temps = i + 1;
    output_row.annee = DateUtils.getYear(currentDate);
    output_row.mois = DateUtils.getMonth(currentDate);
    output_row.mois_annee = String.format("%02d", output_row.mois) 
                          + "-" + output_row.annee;
    
    // Écriture dans le flux de sortie
    row6.id_temps = output_row.id_temps;
    row6.annee = output_row.annee;
    row6.mois_annee = output_row.mois_annee;
}
\end{lstlisting}

\textbf{Power BI (Power Query - équivalent) :}
\begin{lstlisting}[language=PowerQuery, caption=Power Query pour la même transformation]
// Transformation équivalente en Power Query
AnneeAjoutee = Table.AddColumn(DatesUniques, "annee", each Date.Year([DateSource]), Int64.Type),
MoisAjoute = Table.AddColumn(AnneeAjoutee, "mois", each Date.Month([DateSource]), Int64.Type),
MoisAnneeFormate = Table.AddColumn(MoisAjoute, "mois_annee", 
    each Text.PadStart(Text.From([mois]), 2, "0") & "-" & Text.From([annee]), type text),
\end{lstlisting}

\subsection{Recommandation et Justification du Choix}

Le choix de \textbf{Power BI} pour ce projet spécifique se justifie par plusieurs facteurs :

\begin{enumerate}
    \item \textbf{Objectif pédagogique} : Démontrer l'intégration complète ETL+BI dans un seul environnement
    \item \textbf{Prototypage rapide} : Besoin de résultats visuels rapidement exploitables
    \item \textbf{Intégration Python} : Nécessité d'inclure des visualisations Python natives dans le dashboard
    \item \textbf{Simplicité de déploiement} : Solution tout-en-un facile à partager et maintenir
\end{enumerate}

\textbf{Cependant, Talend reste préférable pour :}
\begin{itemize}
    \item Projets à très gros volumes de données (> plusieurs To)
    \item Environnements de production nécessitant une haute disponibilité
    \item Intégrations complexes avec multiples systèmes source
    \item Nécessité de workflow ETL orchestrés et monitorés
\end{itemize}

\subsection{Conclusion de la Comparaison}

Cette expérience avec deux outils ETL différents démontre qu'il n'existe pas de solution universelle, mais plutôt des outils adaptés à différents contextes :

\begin{itemize}
    \item \textbf{Talend} : Optimal pour les \textbf{pipelines ETL industrielles, complexes et scalables}
    \item \textbf{Power BI} : Idéal pour les \textbf{prototypes BI rapides, analyses ad-hoc et projets intégrés}
\end{itemize}

Le choix final s'est porté sur Power BI pour ce projet en raison de son intégration native avec les visualisations interactives et sa capacité à embarquer directement des scripts Python, réduisant ainsi les silos techniques et accélérant le cycle de développement analytique.

% ======================================================================
% SECTION 3 : INSTALLATION ET CONFIGURATION POWER BI
% ======================================================================

\section{Installation et Configuration de Power BI}

\subsection{Installation de Power BI Desktop}

L'installation de Power BI Desktop a été réalisée depuis le site officiel Microsoft : \href{https://powerbi.microsoft.com/fr-fr/desktop/}{https://powerbi.microsoft.com/fr-fr/desktop/}. La version utilisée est Power BI Desktop 2.134.986.0.

\subsection{Configuration de l'Environnement Python}

Pour activer Python dans Power BI :
\begin{enumerate}
    \item Fichier → Options et paramètres → Options
    \item Scripting Python → Spécifier le chemin d'installation Python
    \item Bibliothèques installées via pip :
    \begin{itemize}
        \item \texttt{pandas==2.1.4}
        \item \texttt{matplotlib==3.8.0}
        \item \texttt{numpy==1.24.4}
        \item \texttt{seaborn==0.13.0}
    \end{itemize}
\end{enumerate}

\subsection{Structure du Projet}

Après avoir supprimé les scripts Python indépendants VS Code, la structure du projet est simplifiée et organisée comme suit :

\begin{verbatim}
Projet_Northwind_BI/
│
├── data/
│   ├── raw/           # Données brutes
│   └── processed/     # Données transformées
│       └── kpi.csv    # Fichier KPI généré par Power BI
│
├── powerbi/
│   ├── Northwind.pbix # Fichier principal Power BI
│   └── scripts/       # Scripts Python intégrés
│
├── rapport/
│   └── rapport.tex    # Ce document
│
└── figures/            # Captures d'écran des visualisations
│
│── video/ 
\end{verbatim}

Le fichier \texttt{kpi.csv} dans le dossier \texttt{data/processed/} est généré automatiquement par Power BI lors de l'exécution des scripts Python. Il contient les indicateurs clés de performance calculés à partir des visualisations Python intégrées, permettant une réutilisation dans d'autres analyses ou rapports.

% ======================================================================
% SECTION 4 : ENTREPÔT DE DONNÉES POWER BI
% ======================================================================

\section{Entrepôt de Données Northwind sur Power BI}

\subsection{Modèle Dimensionnel Complet}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{modele_complet.png}
    \caption{Modèle dimensionnel en étoile dans Power BI}
    \label{fig:modele-powerbi}
\end{figure}

\textbf{Description :} Le modèle montre une structure en étoile classique avec :
\begin{itemize}
    \item 1 table de faits : TF\_Commande (878 événements)
    \item 3 tables de dimensions : Dim\_Temps, DimClient, Dim\_Employee
    \item Relations many-to-one configurées via Power BI
\end{itemize}

\subsection{Dimension Temps (Dim\_Temps)}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{Dimension_temps.png}
    \caption{Dimension Temps - 29 périodes temporelles}
    \label{fig:dim-temps}
\end{figure}

\textbf{Caractéristiques :}
\begin{itemize}
    \item 29 périodes uniques (juillet 1996 à novembre 1998)
    \item Colonnes : id\_temps (PK), annee, mois\_annee
    \item Permet l'analyse temporelle des commandes
\end{itemize}

\textbf{Script Power Query M pour Dim\_Temps :}
\begin{lstlisting}[language=PowerQuery, caption=Script Power Query pour la dimension Temps]
// Dim_Temps - Une ligne par combinaison année/mois UNIQUE
let
    // Partie 1 : SQL Server
    DonneesSQL = Sql.Database("localhost", "Northwind"),
    TableOrdersSQL = DonneesSQL{[Schema="dbo",Item="Orders"]}[Data],
    SQLPourTemps = Table.SelectColumns(TableOrdersSQL,{"OrderDate"}),
    SQLAvecSource = Table.AddColumn(SQLPourTemps, "Source", each "SQL Server", type text),
    SQLRenomme = Table.RenameColumns(SQLAvecSource,{{"OrderDate", "DateSource"}}),
    
    // Partie 2 : Excel - FEUILLE "Orders"
    DonneesExcel = Excel.Workbook(File.Contents("C:\Users\GAB Informatique\Documents\Master 2\TBI\TP2\Orders.xlsx"), null, true),
    FeuilleExcel = DonneesExcel{[Item="Orders",Kind="Sheet"]}[Data],
    EnTetetesPromus = Table.PromoteHeaders(FeuilleExcel, [PromoteAllScalars=true]),
    ExcelAvecSource = Table.AddColumn(EnTetetesPromus, "Source", each "Excel", type text),
    ExcelRenomme = Table.RenameColumns(ExcelAvecSource,{{"OrderDate", "DateSource"}}),
    
    // Partie 3 : Fusion AVEC suppression des doublons de dates
    FusionComplete = Table.Combine({SQLRenomme, ExcelRenomme}),
    DatesUniques = Table.Distinct(FusionComplete, {"DateSource"}), // Supprime les dates en double
    
    // Partie 4 : Transformation
    AnneeAjoutee = Table.AddColumn(DatesUniques, "annee", each Date.Year([DateSource]), Int64.Type),
    MoisAjoute = Table.AddColumn(AnneeAjoutee, "mois", each Date.Month([DateSource]), Int64.Type),
    MoisAnneeFormate = Table.AddColumn(MoisAjoute, "mois_annee", 
        each Text.PadStart(Text.From([mois]), 2, "0") & "-" & Text.From([annee]), type text),
    
    // Partie 5 : SUPPRESSION des doublons année/mois_annee
    CombinaisonsUniques = Table.Distinct(MoisAnneeFormate, {"annee", "mois_annee"}),
    
    // Partie 6 : Index final - Seulement les combinaisons UNIQUES
    IndexAjoute = Table.AddIndexColumn(CombinaisonsUniques, "id_temps", 1, 1),
    
    // Partie 7 : Sélection finale
    ColonnesFinales = Table.SelectColumns(IndexAjoute,{"id_temps", "annee", "mois_annee"})
in
    ColonnesFinales
\end{lstlisting}

\textbf{Explication du script :} Ce script Power Query crée la dimension temps en combinant les données de SQL Server et Excel. Il extrait les dates de commande, supprime les doublons, puis crée des combinaisons uniques année-mois. Chaque combinaison unique reçoit un ID unique (id\_temps), créant ainsi une table de dimension propre pour l'analyse temporelle.

\subsection{Dimension Clients (DimClient)}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.85\textwidth]{Dimension_client.png}
    \caption{Dimension Clients - 120 clients uniques}
    \label{fig:dim-clients}
\end{figure}

\textbf{Caractéristiques :}
\begin{itemize}
    \item 120 clients provenant de la fusion SQL Server + Excel
    \item Colonnes clés : CompanyName, City, source\_prod
    \item Permet l'analyse client centric
\end{itemize}

\textbf{Script Power Query M pour DimClient :}
\begin{lstlisting}[language=PowerQuery, caption=Script Power Query pour la dimension Clients]
// DimClient - AVEC suppression doublons
let
    // Partie 1 : SQL Server
    DonneesSQL = Sql.Database("localhost", "Northwind"),
    TableCustomersSQL = DonneesSQL{[Schema="dbo",Item="Customers"]}[Data],
    SQLPourClients = Table.SelectColumns(TableCustomersSQL,{"CustomerID", "CompanyName", "City"}),
    SQLAvecSource = Table.AddColumn(SQLPourClients, "source_prod", each "SQL Server", type text),
    SQLRenomme = Table.RenameColumns(SQLAvecSource,{
        {"CustomerID", "id_client_prod"},
        {"CompanyName", "CompanyName"},
        {"City", "City"}
    }),
    
    // Partie 2 : Excel - FEUILLE "Customers"
    DonneesExcel = Excel.Workbook(File.Contents("C:\Users\GAB Informatique\Documents\Master 2\TBI\TP2\Customers.xlsx"), null, true),
    FeuilleExcel = DonneesExcel{[Item="Customers",Kind="Sheet"]}[Data],
    EnTetetesPromus = Table.PromoteHeaders(FeuilleExcel, [PromoteAllScalars=true]),
    ExcelAvecSource = Table.AddColumn(EnTetetesPromus, "source_prod", each "Excel", type text),
    
    // Détection automatique des colonnes Excel
    ColonnesDisponibles = Table.ColumnNames(EnTetetesPromus),
    ColonneCustomerID = if List.Contains(ColonnesDisponibles, "CustomerID") then "CustomerID"
                   else if List.Contains(ColonnesDisponibles, "Customer Id") then "Customer Id"
                   else if List.Contains(ColonnesDisponibles, "ID") then "ID"
                   else ColonnesDisponibles{0},
                   
    ColonneCompanyName = if List.Contains(ColonnesDisponibles, "CompanyName") then "CompanyName"
                   else if List.Contains(ColonnesDisponibles, "Company Name") then "Company Name"
                   else if List.Contains(ColonnesDisponibles, "Entreprise") then "Entreprise"
                   else ColonnesDisponibles{1},
                   
    ColonneCity = if List.Contains(ColonnesDisponibles, "City") then "City"
             else if List.Contains(ColonnesDisponibles, "Ville") then "Ville"
             else ColonnesDisponibles{2},
    
    ExcelRenomme = Table.RenameColumns(ExcelAvecSource,{
        {ColonneCustomerID, "id_client_prod"},
        {ColonneCompanyName, "CompanyName"},
        {ColonneCity, "City"}
    }),
    
    // Partie 3 : Fusion AVEC suppression des doublons
    FusionComplete = Table.Combine({SQLRenomme, ExcelRenomme}),
    LignesUniques = Table.Distinct(FusionComplete, {"id_client_prod"}), // Supprime les doublons par ID client
    
    // Partie 4 : Index final
    IndexAjoute = Table.AddIndexColumn(LignesUniques, "id_seqClient", 1, 1),
    
    // Partie 5 : Sélection finale
    ColonnesFinales = Table.SelectColumns(IndexAjoute,{"id_seqClient", "id_client_prod", "source_prod", "CompanyName", "City"})
in
    ColonnesFinales
\end{lstlisting}

\textbf{Explication du script :} Ce script combine les données clients provenant de SQL Server et d'Excel. Il utilise une détection automatique des noms de colonnes pour s'adapter aux différentes structures de fichiers Excel. La fonction \texttt{Table.Distinct} élimine les doublons basés sur l'ID client, garantissant l'intégrité référentielle dans le modèle dimensionnel.

\subsection{Dimension Employés (Dim\_Employee)}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.85\textwidth]{Dimension_employee.png}
    \caption{Dimension Employés - 58 employés avec territoires}
    \label{fig:dim-employes}
\end{figure}

\textbf{Caractéristiques :}
\begin{itemize}
    \item 58 employés (8 de SQL Server + 50 d'Excel)
    \item Colonnes : Nom, Prenom, Territory, RegionID
    \item Permet l'analyse des performances par employé
\end{itemize}

\textbf{Script Power Query M pour Dim\_Employee :}
\begin{lstlisting}[language=PowerQuery, caption=Script Power Query pour la dimension Employés]
// Dim_Employee - Version avec RegionID
let
    // Partie 1 : SQL Server
    DonneesSQL = Sql.Database("localhost", "Northwind"),
    EmployeesSQL = DonneesSQL{[Schema="dbo",Item="Employees"]}[Data],
    TerritoriesSQL = DonneesSQL{[Schema="dbo",Item="Territories"]}[Data],
    EmployeeTerritoriesSQL = DonneesSQL{[Schema="dbo",Item="EmployeeTerritories"]}[Data],
    
    // Partie 2 : Jointures SQL Server (sans table Region)
    JointureET = Table.NestedJoin(EmployeesSQL, {"EmployeeID"}, EmployeeTerritoriesSQL, {"EmployeeID"}, "EmpTerr", JoinKind.LeftOuter),
    #"EmpTerr développé" = Table.ExpandTableColumn(JointureET, "EmpTerr", {"TerritoryID"}, {"TerritoryID"}),
    JointureT = Table.NestedJoin(#"EmpTerr développé", {"TerritoryID"}, TerritoriesSQL, {"TerritoryID"}, "Terr", JoinKind.LeftOuter),
    #"Terr développé" = Table.ExpandTableColumn(JointureT, "Terr", {"TerritoryDescription", "RegionID"}, {"TerritoryDescription", "RegionID"}),
    
    // Partie 3 : Transformation SQL Server
    SQLPourEmployes = Table.SelectColumns(#"Terr développé",{"EmployeeID", "LastName", "FirstName", "TerritoryDescription", "RegionID"}),
    SQLRenomme = Table.RenameColumns(SQLPourEmployes,{
        {"LastName", "Nom"},
        {"FirstName", "Prenom"}, 
        {"TerritoryDescription", "Territory"},
        {"RegionID", "RegionID"}
    }),
    SQLAvecSource = Table.AddColumn(SQLRenomme, "source_prod", each "SQL Server", type text),
    SQLAvecDescri = Table.AddColumn(SQLAvecSource, "TerritoryDescri", each [Territory], type text),
    SQLFinal = Table.SelectColumns(SQLAvecDescri,{"EmployeeID", "Nom", "Prenom", "Territory", "TerritoryDescri", "RegionID", "source_prod"}),
    
    // Partie 4 : Excel - FICHIER "Employees.xlsx"
    DonneesExcel = Excel.Workbook(File.Contents("C:\Users\GAB Informatique\Documents\Master 2\TBI\TP2\Employees.xlsx"), null, true),
    FeuilleExcel = DonneesExcel{[Item="Employees",Kind="Sheet"]}[Data],
    EnTetetesPromus = Table.PromoteHeaders(FeuilleExcel, [PromoteAllScalars=true]),
    
    // Détection automatique des colonnes Excel
    ColonnesDisponibles = Table.ColumnNames(EnTetetesPromus),
    ColonneEmployeeID = if List.Contains(ColonnesDisponibles, "EmployeeID") then "EmployeeID"
                   else if List.Contains(ColonnesDisponibles, "Employee Id") then "Employee Id"
                   else if List.Contains(ColonnesDisponibles, "ID") then "ID"
                   else ColonnesDisponibles{0},
                   
    ColonneLastName = if List.Contains(ColonnesDisponibles, "LastName") then "LastName"
                 else if List.Contains(ColonnesDisponibles, "Last Name") then "Last Name"
                 else if List.Contains(ColonnesDisponibles, "Nom") then "Nom"
                 else ColonnesDisponibles{1},
                 
    ColonneFirstName = if List.Contains(ColonnesDisponibles, "FirstName") then "FirstName"
                  else if List.Contains(ColonnesDisponibles, "First Name") then "First Name"
                  else if List.Contains(ColonnesDisponibles, "Prénom") then "Prénom"
                  else ColonnesDisponibles{2},

    // Renommage des colonnes Excel
    ExcelRenomme = Table.RenameColumns(EnTetetesPromus,{
        {ColonneEmployeeID, "EmployeeID"},
        {ColonneLastName, "Nom"},
        {ColonneFirstName, "Prenom"}
    }),
    
    // Gestion des territoires pour Excel
    ExcelAvecTerritoire = if List.Contains(ColonnesDisponibles, "TerritoryDescription") then 
        Table.RenameColumns(ExcelRenomme,{{"TerritoryDescription", "Territory"}})
    else if List.Contains(ColonnesDisponibles, "Territory") then 
        ExcelRenomme
    else 
        Table.AddColumn(ExcelRenomme, "Territory", each "Non spécifié", type text),
        
    // Gestion de RegionID pour Excel
    ExcelAvecRegionID = if List.Contains(ColonnesDisponibles, "RegionID") then 
        ExcelAvecTerritoire
    else if List.Contains(ColonnesDisponibles, "Region ID") then 
        Table.RenameColumns(ExcelAvecTerritoire,{{"Region ID", "RegionID"}})
    else if List.Contains(ColonnesDisponibles, "Region") then 
        // Convertir Region en RegionID si nécessaire
        Table.AddColumn(ExcelAvecTerritoire, "RegionID", 
            each if [Region] = "Eastern" then 1
            else if [Region] = "Western" then 2
            else if [Region] = "Northern" then 3
            else if [Region] = "Southern" then 4
            else 0, Int64.Type)
    else 
        Table.AddColumn(ExcelAvecTerritoire, "RegionID", each 0, Int64.Type),
    
    // Supprimer la colonne Region si elle existe
    ColonnesApresRegion = Table.ColumnNames(ExcelAvecRegionID),
    ExcelSansRegion = if List.Contains(ColonnesApresRegion, "Region") then 
        Table.RemoveColumns(ExcelAvecRegionID,{"Region"})
    else ExcelAvecRegionID,
    
    ExcelAvecDescri = Table.AddColumn(ExcelSansRegion, "TerritoryDescri", each [Territory], type text),
    ExcelAvecSource = Table.AddColumn(ExcelAvecDescri, "source_prod", each "Excel", type text),
    ExcelFinal = Table.SelectColumns(ExcelAvecSource,{"EmployeeID", "Nom", "Prenom", "Territory", "TerritoryDescri", "RegionID", "source_prod"}),
    
    // Partie 5 : Fusion COMPLÈTE
    FusionComplete = Table.Combine({SQLFinal, ExcelFinal}),
    
    // Partie 6 : Index final
    IndexAjoute = Table.AddIndexColumn(FusionComplete, "id_seqEmployee", 1, 1),
    
    // Partie 7 : Sélection finale
    ColonnesFinales = Table.SelectColumns(IndexAjoute,{
        "id_seqEmployee", "EmployeeID", "source_prod", "Nom", "Prenom", 
        "Territory", "TerritoryDescri", "RegionID"
    }),
    ColonneRenommee = Table.RenameColumns(ColonnesFinales,{{"EmployeeID", "id_employee_prod"}})
in
    ColonneRenommee
\end{lstlisting}

\textbf{Explication du script :} Ce script complexe crée la dimension employés en combinant et normalisant les données provenant de SQL Server (avec ses relations entre tables) et d'Excel. Il gère intelligemment les différentes structures de données grâce à la détection automatique des colonnes et la transformation conditionnelle des régions en RegionID.

\subsection{Table de Faits (TF\_Commande)}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{Table_de_faits_commandes.png}
    \caption{Table de faits - 878 événements commandes}
    \label{fig:tf-commandes}
\end{figure}

\textbf{Caractéristiques :}
\begin{itemize}
    \item 878 commandes (830 SQL Server + 48 Excel)
    \item Métriques : nbr\_commande\_livrees, nbr\_commande\_non\_livrees
    \item Clés étrangères vers toutes les dimensions
\end{itemize}

\textbf{Script Power Query M pour TF\_Commande :}
\begin{lstlisting}[language=PowerQuery, caption=Script Power Query pour la table de faits]
// TF_Commande - Version adaptative
let
    // Partie 1 : SQL Server - Orders
    DonneesSQL = Sql.Database("localhost", "Northwind"),
    TableOrdersSQL = DonneesSQL{[Schema="dbo",Item="Orders"]}[Data],
    SQLPourCommandes = Table.SelectColumns(TableOrdersSQL,{"OrderID", "OrderDate", "EmployeeID", "CustomerID", "ShippedDate"}),
    SQLAvecSource = Table.AddColumn(SQLPourCommandes, "Source", each "SQL", type text),
    
    // Partie 2 : Excel - Version adaptative
    DonneesExcel = Excel.Workbook(File.Contents("C:\Users\GAB Informatique\Documents\Master 2\TBI\TP2\Orders_FAIT.xlsx"), null, true),
    FeuilleExcel = DonneesExcel{[Item="Orders",Kind="Sheet"]}[Data],
    EnTetetesPromus = Table.PromoteHeaders(FeuilleExcel, [PromoteAllScalars=true]),
    
    // Détection automatique des colonnes
    ColonnesDisponibles = Table.ColumnNames(EnTetetesPromus),
    
    // Renommage adaptatif basé sur les colonnes disponibles
    ExcelRenomme = if List.Contains(ColonnesDisponibles, "Employee ID") then
        Table.RenameColumns(EnTetetesPromus,{
            {"Employee ID", "EmployeeID"},
            {"Customer ID", "CustomerID"}, 
            {"Order Date", "OrderDate"},
            {"Shipped Date", "ShippedDate"}
        })
    else if List.Contains(ColonnesDisponibles, "EmployeeID") then
        EnTetetesPromus // Déjà bons noms
    else
        // Si les colonnes ont d'autres noms, utiliser les premières colonnes
        Table.RenameColumns(EnTetetesPromus,{
            {ColonnesDisponibles{0}, "EmployeeID"},
            {ColonnesDisponibles{1}, "CustomerID"},
            {ColonnesDisponibles{2}, "OrderDate"},
            {ColonnesDisponibles{3}, "ShippedDate"}
        }),
    
    // Ajouter OrderID manquant pour Excel
    ExcelAvecOrderID = Table.AddColumn(ExcelRenomme, "OrderID", 
        each "EXCEL-" & Text.From([EmployeeID]) & "-" & Text.From([CustomerID]) & "-" & Text.From([OrderDate]), type text),
    ExcelAvecSource = Table.AddColumn(ExcelAvecOrderID, "Source", each "Excel", type text),
    
    // Partie 3 : Fusion COMPLÈTE des données
    FusionComplete = Table.Combine({SQLAvecSource, ExcelAvecSource}),
    
    // Partie 4 : SUPPRESSION DES DOUBLONS 
    LignesUniques = Table.Distinct(FusionComplete, {"OrderID"}),
    
    // Partie 5 : Création des colonnes pour la jointure avec Dim_temps
    AnneeMoisAjoutes = Table.AddColumn(LignesUniques, "annee_commande", each Date.Year([OrderDate]), Int64.Type),
    MoisAnneeAjoute = Table.AddColumn(AnneeMoisAjoutes, "mois_annee_commande", 
        each Text.PadStart(Text.From(Date.Month([OrderDate])), 2, "0") & "-" & Text.From(Date.Year([OrderDate])), type text),
    
    // Partie 6 : Jointure avec Dim_temps (LEFT OUTER)
    DimTemps = Dim_temps,
    JointureTemps = Table.Join(MoisAnneeAjoute, {"annee_commande", "mois_annee_commande"}, DimTemps, {"annee", "mois_annee"}, JoinKind.LeftOuter),
    
    // Partie 7 : Jointure avec Dim_employee (LEFT OUTER)
    DimEmployee = Dim_employee,
    EmployeeSansDoublons = Table.Distinct(Table.SelectColumns(DimEmployee, {"id_employee_prod", "id_seqEmployee"}), {"id_employee_prod"}),
    JointureEmployee = Table.Join(JointureTemps, "EmployeeID", EmployeeSansDoublons, "id_employee_prod", JoinKind.LeftOuter),
    
    // Partie 8 : Jointure avec Dim_client (LEFT OUTER)
    DimClient = Dim_client,
    ClientSansDoublons = Table.Distinct(Table.SelectColumns(DimClient, {"id_client_prod", "id_seqClient"}), {"id_client_prod"}),
    JointureClient = Table.Join(JointureEmployee, "CustomerID", ClientSansDoublons, "id_client_prod", JoinKind.LeftOuter),
    
    // Partie 9 : Calcul des métriques
    CommandesLivrees = Table.AddColumn(JointureClient, "nbr_commande_livrees", 
        each if [ShippedDate] <> null then 1 else 0, Int64.Type),
        
    CommandesNonLivrees = Table.AddColumn(CommandesLivrees, "nbr_commande_non_livrees", 
        each if [ShippedDate] = null then 1 else 0, Int64.Type),
    
    // Partie 10 : Index final
    IndexAjoute = Table.AddIndexColumn(CommandesNonLivrees, "id_seq_fait", 1, 1),
    
    // Partie 11 : Sélection des colonnes finales
    ColonnesFinales = Table.SelectColumns(IndexAjoute,{
        "id_seq_fait", 
        "id_temps", 
        "id_seqEmployee", 
        "id_seqClient", 
        "nbr_commande_livrees", 
        "nbr_commande_non_livrees"
    })
in
    ColonnesFinales
\end{lstlisting}

\textbf{Explication du script :} Ce script crée la table de faits en joignant les données de commandes avec les trois dimensions. Il utilise des jointures LEFT OUTER pour s'assurer que toutes les commandes sont conservées, même si certaines dimensions manquent. Le script génère également des métriques calculées (commandes livrées vs non livrées) et crée des IDs uniques pour chaque enregistrement de fait.

% ======================================================================
% SECTION 5 : VISUALISATIONS POWER BI AVEC PYTHON
% ======================================================================

\section{Visualisations Power BI avec Python}

Cette section présente l'ensemble des visualisations Python intégrées dans le dashboard Power BI. Chaque visualisation combine la puissance d'analyse de Python avec l'interactivité de Power BI.

\subsection{Visualisation 1 : Top 10 Clients}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{top10clientspng.png}
    \caption{Top 10 Clients - Analyse comparative des performances}
    \label{fig:top10-clients}
\end{figure}

\textbf{Objectif :} Identifier les clients les plus performants en termes de volume de commandes.

\textbf{Description :} Cette visualisation présente les 10 clients ayant le plus grand nombre de commandes livrées. Elle utilise un diagramme à barres horizontales pour faciliter la comparaison. Chaque barre est annotée avec le nombre exact de commandes.

\textbf{Script Python :}
\begin{lstlisting}[language=Python, caption=Script Python pour Top 10 Clients]
import pandas as pd
import matplotlib.pyplot as plt

# Colonnes nécessaires : CompanyName, nbr_commande_livrees
top_clients = dataset.groupby('CompanyName')['nbr_commande_livrees']\
    .sum()\
    .sort_values(ascending=False)\
    .head(10)

plt.figure(figsize=(12, 6))
bars = plt.barh(top_clients.index, top_clients.values)
plt.xlabel('Nombre de Commandes Livrées')
plt.title('Top 10 Clients par Commandes Livrées')
plt.gca().invert_yaxis()

# Ajouter les valeurs sur les barres
for bar in bars:
    width = bar.get_width()
    plt.text(width, bar.get_y() + bar.get_height()/2, 
             f'{int(width)}', ha='left', va='center')

plt.tight_layout()
plt.show()
\end{lstlisting}

\subsection{Visualisation 2 : Performance par Employé}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{performance_par_employe.png}
    \caption{Performance par Employé - Analyse individuelle}
    \label{fig:performance-employes}
\end{figure}

\textbf{Objectif :} Évaluer la performance individuelle des employés avec analyse des taux de livraison.

\textbf{Description :} Cette visualisation avancée combine deux graphiques : des barres groupées montrant les commandes livrées vs non livrées et une ligne montrant le taux de livraison. Elle permet d'identifier simultanément les employés avec le plus grand volume et ceux avec la meilleure qualité de service.

\textbf{Script Python :}
\begin{lstlisting}[language=Python, caption=Script Python pour Performance des Employés]
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

# Créer la colonne Employe
df = dataset.copy()
df['Employe'] = df['Nom'] + ' ' + df['Prenom']

# Regrouper par employé et RegionID
perf_employe = df.groupby(['Employe', 'RegionID']).agg({
    'nbr_commande_livrees': 'sum',
    'nbr_commande_non_livrees': 'sum'
}).reset_index()

# Calculer le taux de livraison
perf_employe['total_commandes'] = perf_employe['nbr_commande_livrees'] + perf_employe['nbr_commande_non_livrees']
perf_employe['taux_livraison'] = (perf_employe['nbr_commande_livrees'] / perf_employe['total_commandes']) * 100

# Trier et prendre top 15
perf_employe = perf_employe.sort_values('nbr_commande_livrees', ascending=False).head(15)

# Créer la visualisation
fig, ax1 = plt.subplots(figsize=(14, 8))

x = np.arange(len(perf_employe))
width = 0.35

bars1 = ax1.bar(x - width/2, perf_employe['nbr_commande_livrees'], 
                width, label='Livrées', color='green', alpha=0.7)
bars2 = ax1.bar(x + width/2, perf_employe['nbr_commande_non_livrees'], 
                width, label='Non Livrées', color='red', alpha=0.7)

ax1.set_xlabel('Employé')
ax1.set_ylabel('Nombre de Commandes')
ax1.set_title('Performance des Employés (Top 15)')
ax1.set_xticks(x)
ax1.set_xticklabels(perf_employe['Employe'], rotation=45, ha='right')
ax1.legend()

# Deuxième axe pour le taux de livraison
ax2 = ax1.twinx()
ax2.plot(x, perf_employe['taux_livraison'], 'b--', marker='o', 
         label='Taux Livraison (%)', linewidth=2)
ax2.set_ylabel('Taux de Livraison (%)')
ax2.set_ylim(0, 100)
ax2.legend(loc='upper right')

# Ajouter des annotations
for i, (idx, row) in enumerate(perf_employe.iterrows()):
    ax1.text(i - width/2, row['nbr_commande_livrees'] + 1, 
             str(int(row['nbr_commande_livrees'])), ha='center', va='bottom')
    ax1.text(i + width/2, row['nbr_commande_non_livrees'] + 1, 
             str(int(row['nbr_commande_non_livrees'])), ha='center', va='bottom')
    ax2.text(i, row['taux_livraison'] + 2, f"{row['taux_livraison']:.1f}%", 
             ha='center', va='bottom')

plt.tight_layout()
plt.show()
\end{lstlisting}

\subsection{Visualisation 3 : Commandes Livrées par Ville}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{commandes_livrées_pae_ville.png}
    \caption{Commandes Livrées par Ville - Analyse géographique}
    \label{fig:commandes-ville}
\end{figure}

\textbf{Objectif :} Analyser la répartition géographique des livraisons.

\textbf{Description :} Cette visualisation utilise un diagramme circulaire (pie chart) pour montrer la répartition des commandes par ville. Les 10 principales villes sont représentées individuellement, tandis que les autres sont regroupées dans une catégorie "Autres". Chaque segment affiche le pourcentage et le nombre absolu de commandes.

\textbf{Script Python :}
\begin{lstlisting}[language=Python, caption=Script Python pour Commandes par Ville]
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

# Agrégation par ville
df = dataset.groupby('City')['nbr_commande_livrees']\
    .sum()\
    .sort_values(ascending=False)\
    .reset_index()

# Calculer les totaux
total_commandes = df['nbr_commande_livrees'].sum()

# Prendre top 10 villes
top_n = 10
df_top = df.head(top_n).copy()
autres_total = df.iloc[top_n:]['nbr_commande_livrees'].sum()

# Ajouter la ligne "Autres"
if autres_total > 0:
    df_final = pd.concat([
        df_top,
        pd.DataFrame({'City': ['Autres'], 'nbr_commande_livrees': [autres_total]})
    ])
else:
    df_final = df_top

# Calculer les pourcentages
df_final['pourcentage'] = (df_final['nbr_commande_livrees'] / total_commandes) * 100

# Création du graphique
plt.figure(figsize=(12, 10))

# Palette de couleurs
colors = plt.cm.Set3(np.linspace(0, 1, len(df_final)))

# Diagramme en secteurs
wedges, texts, autotexts = plt.pie(
    df_final['nbr_commande_livrees'], 
    labels=df_final['City'],
    autopct=lambda pct: f'{pct:.1f}%\n({int(pct*total_commandes/100):,})',
    colors=colors,
    startangle=90,
    textprops={'fontsize': 10}
)

# Améliorer la lisibilité
for autotext in autotexts:
    autotext.set_color('black')
    autotext.set_fontweight('bold')

plt.title(f'Répartition des Commandes Livrées par Ville\nTotal: {total_commandes:,} commandes', 
          fontsize=14, fontweight='bold')
plt.axis('equal')

# Ajouter une légende avec les valeurs détaillées
plt.legend(
    wedges, 
    [f"{row.City}: {row.nbr_commande_livrees:,} ({row.pourcentage:.1f}%)" 
     for _, row in df_final.iterrows()],
    title="Détails par ville",
    loc="center left",
    bbox_to_anchor=(1, 0, 0.5, 1),
    fontsize=9
)

plt.tight_layout()
plt.show()
\end{lstlisting}

\subsection{Visualisation 4 : Évolution Temporelle des Régions}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{evolution_regions.png}
    \caption{Évolution Temporelle - Performance par Région}
    \label{fig:evolution-regions}
\end{figure}

\textbf{Objectif :} Analyser les tendances de performance des régions dans le temps.

\textbf{Description :} Ce graphique linéaire montre l'évolution du taux de livraison pour chaque région sur plusieurs périodes. Une ligne horizontale rouge indique l'objectif de 90\%. Cela permet d'identifier les régions qui s'améliorent, celles qui stagnent et celles qui nécessitent une attention particulière.

\textbf{Script Python :}
\begin{lstlisting}[language=Python, caption=Script Python pour Évolution Temporelle]
# VISUALISATION 4 : ÉVOLUTION TEMPORELLE DES RÉGIONS
import pandas as pd
import matplotlib.pyplot as plt
from datetime import datetime

df = dataset.copy()

# Analyser taux par région et période
region_time = df.groupby(['RegionID', 'mois_annee']).agg({
    'nbr_commande_livrees': 'sum',
    'nbr_commande_non_livrees': 'sum'
}).reset_index()

region_time['total'] = region_time['nbr_commande_livrees'] + region_time['nbr_commande_non_livrees']
region_time['taux'] = (region_time['nbr_commande_livrees'] / region_time['total'] * 100)

# Vérifier le format de mois_annee
print("Exemple de valeurs mois_annee:", region_time['mois_annee'].unique()[:5])

# OPTION 1: Si mois_annee est au format datetime
if pd.api.types.is_datetime64_any_dtype(region_time['mois_annee']):
    region_time = region_time.sort_values('mois_annee')
    periods = sorted(region_time['mois_annee'].unique())
    
# OPTION 2: Si mois_annee est au format "MM-YYYY" ou "MM/YYYY"
elif region_time['mois_annee'].astype(str).str.contains(r'\d{1,2}[-/]\d{4}').any():
    # Convertir en datetime
    region_time['date_temp'] = pd.to_datetime(region_time['mois_annee'], errors='coerce')
    region_time = region_time.sort_values('date_temp')
    periods = sorted(region_time['mois_annee'].unique(), 
                     key=lambda x: datetime.strptime(x, '%m-%Y') if '-' in x else datetime.strptime(x, '%m/%Y'))
    
# OPTION 3: Si mois_annee est au format "Jan-2024", "Fev-2024", etc.
elif region_time['mois_annee'].astype(str).str.contains(r'[A-Za-z]+-\d{4}').any():
    # Définir l'ordre des mois en français
    mois_fr = ['Jan', 'Fev', 'Mar', 'Avr', 'Mai', 'Juin', 'Juil', 'Aout', 'Sep', 'Oct', 'Nov', 'Dec',
               'Janvier', 'Février', 'Mars', 'Avril', 'Mai', 'Juin', 'Juillet', 'Août', 'Septembre', 'Octobre', 'Novembre', 'Décembre']
    
    def sort_date_fr(date_str):
        try:
            mois, annee = date_str.split('-')
            mois_index = next((i for i, m in enumerate(mois_fr) if m.lower() in mois.lower()), 0)
            return (int(annee), mois_index % 12)
        except:
            return (0, 0)
    
    region_time = region_time.sort_values('mois_annee', key=lambda x: x.map(sort_date_fr))
    periods = sorted(region_time['mois_annee'].unique(), key=sort_date_fr)

# OPTION 4: Format général
else:
    # Essayer plusieurs formats de date
    for fmt in ['%Y-%m', '%m-%Y', '%Y/%m', '%m/%Y', '%b-%Y', '%B-%Y']:
        try:
            region_time['date_temp'] = pd.to_datetime(region_time['mois_annee'], format=fmt, errors='coerce')
            if region_time['date_temp'].notna().all():
                region_time = region_time.sort_values('date_temp')
                periods = sorted(region_time['mois_annee'].unique())
                break
        except:
            continue
    else:
        # Fallback: tri alphabétique
        region_time = region_time.sort_values('mois_annee')
        periods = sorted(region_time['mois_annee'].unique())

fig, ax = plt.subplots(figsize=(14, 7))

regions = sorted(region_time['RegionID'].unique())
colors_list = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6']

# Créer un mapping date -> position
date_to_position = {date: i for i, date in enumerate(periods)}

for i, region in enumerate(regions):
    data = region_time[region_time['RegionID'] == region].sort_values('mois_annee', 
                                                                      key=lambda x: x.map(date_to_position.get))
    
    # Vérifier que les données sont bien triées
    print(f"Région {region} - Dates: {list(data['mois_annee'].values)}")
    
    x_positions = [date_to_position[date] for date in data['mois_annee']]
    ax.plot(x_positions, data['taux'].values, 'o-', linewidth=2.5, markersize=7,
            label=region, color=colors_list[i % len(colors_list)])

ax.axhline(y=90, color='red', linestyle='--', linewidth=2, alpha=0.6, label='Target (90%)')
ax.set_xlabel('Période', fontweight='bold', fontsize=11)
ax.set_ylabel('Taux de Livraison (%)', fontweight='bold', fontsize=11)
ax.set_title('Évolution Temporelle - Performance par Région\n(Tendances, déviations, convergence)', 
             fontsize=13, fontweight='bold')

# Définir les ticks avec les périodes triées chronologiquement
ax.set_xticks(range(len(periods)))
ax.set_xticklabels(periods, rotation=45, ha='right')

ax.set_ylim(70, 105)
ax.grid(True, alpha=0.3)
ax.legend(loc='best', fontsize=10)

plt.tight_layout()
plt.show()

print("\n=== TENDANCE PAR RÉGION ===")
for region in regions:
    data = region_time[region_time['RegionID'] == region].sort_values('mois_annee', 
                                                                      key=lambda x: x.map(date_to_position.get))
    first_rate = data['taux'].iloc[0]
    last_rate = data['taux'].iloc[-1]
    trend = "↑" if last_rate > first_rate else "↓" if last_rate < first_rate else "="
    print(f"{region}: {first_rate:.1f}% → {last_rate:.1f}% {trend}")

print("\nPériodes affichées (tri chronologique):", periods)
\end{lstlisting}

\subsection{Visualisation 5 : Matrice de Communication - Qui vend à qui}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{matrice_communication.png}
    \caption{Matrice Couverture Clients-Employés}
    \label{fig:matrice-communication}
\end{figure}

\textbf{Objectif :} Visualiser la répartition des clients entre les employés.

\textbf{Description :} Cette heatmap montre quels employés travaillent avec quels clients. Les cellules colorées indiquent le nombre de commandes livrées, permettant d'identifier rapidement les employés polyvalents, les dépendances clients et les opportunités de redistribution de la charge de travail.

\textbf{Script Python :}
\begin{lstlisting}[language=Python, caption=Script Python pour Matrice de Communication]
# VISUALISATION 5 : MATRICE DE COMMUNICATION - QUI VEND À QUI
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

df = dataset.copy()
df['Employe'] = df['Nom'] + ' ' + df['Prenom']

# Créer une matrice Employé x Client (Top 10 clients, Top 8 employés)
top_clients = df.groupby('CompanyName')['nbr_commande_livrees'].sum().nlargest(10).index
top_emps = df.groupby('Employe')['nbr_commande_livrees'].sum().nlargest(8).index

df_filtered = df[(df['CompanyName'].isin(top_clients)) & (df['Employe'].isin(top_emps))]

matrice = df_filtered.groupby(['Employe', 'CompanyName'])['nbr_commande_livrees'].sum().unstack(fill_value=0)

plt.figure(figsize=(12, 8))
sns.heatmap(matrice, annot=True, fmt='g', cmap='YlOrRd', cbar_kws={'label': 'Commandes Livrées'},
            linewidths=0.5, linecolor='gray')
plt.title('Matrice Couverture Clients-Employés\n(Identification des zones de concentration)', 
          fontsize=13, fontweight='bold')
plt.xlabel('Clients (Top 10)', fontweight='bold')
plt.ylabel('Employés (Top 8)', fontweight='bold')
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()
\end{lstlisting}

\subsection{Visualisation 6 : Impact du Taux de Livraison sur la Rétention Clients}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{impact_retention.png}
    \caption{Impact du Taux de Livraison sur la Rétention Clients}
    \label{fig:impact-retention}
\end{figure}

\textbf{Objectif :} Analyser la corrélation entre la qualité de service et la fidélité des clients.

\textbf{Description :} Cette visualisation composée de 4 graphiques analyse comment le taux de livraison affecte le comportement des clients. Elle segmente les clients en 4 catégories (Critique, Faible, Bon, Excellent) et montre pour chaque segment le nombre de clients, le volume moyen de commandes, et la répartition totale.

\textbf{Script Python :}
\begin{lstlisting}[language=Python, caption=Script Python pour Impact sur la Rétention]
# VISUALISATION 6 : IMPACT DU TAUX DE LIVRAISON SUR LA RÉTENTION CLIENTS
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

df = dataset.copy()
df['total_commandes'] = df['nbr_commande_livrees'] + df['nbr_commande_non_livrees']
df['taux_livraison'] = (df['nbr_commande_livrees'] / df['total_commandes'] * 100)

# Segmenter les clients par taux et analyser leur fidélité
client_seg = df.groupby('CompanyName').agg({
    'total_commandes': 'sum',
    'taux_livraison': 'mean',
    'id_seqClient': 'count'  # Nombre de transactions
}).reset_index()

client_seg.columns = ['CompanyName', 'total_commandes', 'taux_livraison', 'nb_transactions']

# Créer des bacs de taux
client_seg['segment_taux'] = pd.cut(client_seg['taux_livraison'], 
                                     bins=[0, 70, 85, 95, 100],
                                     labels=['Critique (<70%)', 'Faible (70-85%)', 'Bon (85-95%)', 'Excellent (>95%)'])

fig, axes = plt.subplots(2, 2, figsize=(15, 10))

# Graph 1 : Nombre de clients par segment
seg_counts = client_seg.groupby('segment_taux').size()
axes[0, 0].bar(range(len(seg_counts)), seg_counts.values, 
               color=['#c0392b', '#f39c12', '#f1c40f', '#27ae60'], alpha=0.8)
axes[0, 0].set_xticks(range(len(seg_counts)))
axes[0, 0].set_xticklabels(seg_counts.index, rotation=45, ha='right')
axes[0, 0].set_ylabel('Nombre de Clients')
axes[0, 0].set_title('Distribution des Clients par Segment de Qualité')
axes[0, 0].grid(axis='y', alpha=0.3)

# Graph 2 : Commandes moyennes par client
seg_cmd = client_seg.groupby('segment_taux')['total_commandes'].mean()
axes[0, 1].bar(range(len(seg_cmd)), seg_cmd.values, 
               color=['#c0392b', '#f39c12', '#f1c40f', '#27ae60'], alpha=0.8)
axes[0, 1].set_xticks(range(len(seg_cmd)))
axes[0, 1].set_xticklabels(seg_cmd.index, rotation=45, ha='right')
axes[0, 1].set_ylabel('Commandes par Client (moyenne)')
axes[0, 1].set_title('Fidélité Clients par Segment de Qualité')
axes[0, 1].grid(axis='y', alpha=0.3)

# Graph 3 : Taux de livraison moyen
seg_taux = client_seg.groupby('segment_taux')['taux_livraison'].mean()
axes[1, 0].bar(range(len(seg_taux)), seg_taux.values, 
               color=['#c0392b', '#f39c12', '#f1c40f', '#27ae60'], alpha=0.8)
axes[1, 0].set_xticks(range(len(seg_taux)))
axes[1, 0].set_xticklabels(seg_taux.index, rotation=45, ha='right')
axes[1, 0].set_ylabel('Taux de Livraison (%)')
axes[1, 0].set_title('Taux Moyen par Segment')
axes[1, 0].set_ylim(0, 105)
axes[1, 0].grid(axis='y', alpha=0.3)

# Graph 4 : Volume total par segment
seg_vol = client_seg.groupby('segment_taux')['total_commandes'].sum()
axes[1, 1].pie(seg_vol.values, labels=seg_vol.index, autopct='%1.1f%%',
               colors=['#c0392b', '#f39c12', '#f1c40f', '#27ae60'], startangle=90)
axes[1, 1].set_title('Répartition du Volume par Segment')

plt.suptitle('Impact du Taux de Livraison sur la Rétention Clients', 
             fontsize=14, fontweight='bold', y=1.00)
plt.tight_layout()
plt.show()
\end{lstlisting}

% ======================================================================
% SECTION 6 : TIMELINE INTERACTIVE DU PROJET
% ======================================================================

\section{Timeline Interactive du Projet}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{timeline_projet.png}
    \caption{Timeline Interactive - Phases du Projet Northwind BI}
    \label{fig:timeline-projet}
\end{figure}

\textbf{Description :} Cette timeline interactive illustre les différentes phases du projet Northwind BI, depuis la modélisation initiale jusqu'au développement des visualisations avancées. Elle montre clairement la progression chronologique et l'imbrication des différentes activités :

\begin{itemize}
    \item \textbf{Phase 1 : Modélisation} (Semaines 1-2) : Création de l'entrepôt de données et des tables dimensionnelles
    \item \textbf{Phase 2 : Intégration Power BI} (Semaines 3-4) : Configuration de Power BI et développement des premières visualisations
    \item \textbf{Phase 3 : Python Avancé} (Semaines 5-6) : Développement des visualisations Python complexes
    \item \textbf{Phase 4 : Consolidation} (Semaines 7-8) : Tests, optimisation et documentation
\end{itemize}

La timeline montre également comment les différentes visualisations se sont construites les unes sur les autres, avec une complexité croissante au fil du projet.

% ======================================================================
% SECTION 7 : SYNTHÈSE DES ANALYSES
% ======================================================================

\section{Synthèse des Analyses et Recommandations}

\subsection{Principaux Résultats}

\begin{table}[H]
\centering
\begin{tabular}{|l|l|l|}
\hline
\textbf{Visualisation} & \textbf{Objectif} & \textbf{Principale Insight} \\
\hline
Top 10 Clients & Identifier les meilleurs clients & Concentration sur 10\% des clients \\
\hline
Performance Employés & Évaluer l'efficacité commerciale & Grandes variations de performance \\
\hline
Commandes par Ville & Analyse géographique & Londres = 22\% des commandes totales \\
\hline
Évolution Régions & Suivi temporel & Région 3 sous-performe (<85\%) \\
\hline
Matrice Communication & Couverture clients & Inégalités dans la distribution clients \\
\hline
Impact Rétention & Qualité service vs fidélité & Forte corrélation positive \\
\hline
\end{tabular}
\caption{Synthèse des analyses réalisées}
\end{table}

\subsection{Recommandations Stratégiques}

\textbf{1. Amélioration du Taux de Livraison :}
\begin{itemize}
    \item Cibler la Région 3 pour analyse approfondie des causes
    \item Mettre en place un plan d'action pour atteindre 90\% dans toutes les régions
    \item Système d'alertes pour détecter les baisses de performance
\end{itemize}

\textbf{2. Optimisation de la Couverture Clients :}
\begin{itemize}
    \item Redistribution équilibrée des comptes clients entre employés
    \item Programme de mentorat pour partager les meilleures pratiques
    \item Formation cross-selling pour augmenter la valeur par client
\end{itemize}

\textbf{3. Fidélisation Client :}
\begin{itemize}
    \item Programme spécial pour les clients du segment "Critique"
    \item Reconnaissance des clients "Excellent" (programme VIP)
    \item Communication proactive sur les améliorations de service
\end{itemize}

\subsection{Indicateurs Clés de Performance (KPI)}

\begin{enumerate}
    \item \textbf{Taux de Livraison Global} : Objectif > 95\% (actuel : 88\%)
    \item \textbf{Répartition Équilibrée Clients} : Pas d'employé avec > 30\% des revenus
    \item \textbf{Fidélisation Client} : Réduction de 50\% des clients segment "Critique"
    \item \textbf{Performance Régionale} : Toutes les régions > 90\% de taux de livraison
    \item \textbf{Satisfaction Client} : Mise en place d'un système de mesure
\end{enumerate}

% ======================================================================
% SECTION 8 : CONCLUSION ET PERSPECTIVES
% ======================================================================

\section{Conclusion et Perspectives}

\subsection{Synthèse des Réalisations}

Ce projet a démontré avec succès :

\begin{enumerate}
    \item \textbf{Modélisation de données} : Création d'un entrepôt dimensionnel complet pour Northwind avec structure optimisée
    \item \textbf{Intégration technologique} : Combinaison efficace de Power BI (ETL, dashboarding) et Python (analyses avancées)
    \item \textbf{Analyse commerciale} : Développement de 6 visualisations analytiques pertinentes pour le business
    \item \textbf{Automatisation} : Génération automatique du fichier KPI.csv pour reporting ultérieur
    \item \textbf{Recommandations actionnables} : Insights concrets pour l'amélioration des performances
\end{enumerate}

\subsection{Avantages de l'Approche Hybride}

\begin{table}[H]
\centering
\begin{tabular}{|l|l|l|}
\hline
\textbf{Aspect} & \textbf{Power BI} & \textbf{Python dans Power BI} \\
\hline
ETL et modélisation & Excellent & Complémentaire \\
\hline
Dashboarding interactif & Exceptionnel & Intégré au dashboard \\
\hline
Analyses statistiques & Basique & Avancé via scripts \\
\hline
Visualisations personnalisées & Standard & Hautement personnalisable \\
\hline
Maintenance & Facilitée & Nécessite expertise mais intégrée \\
\hline
Performance & Optimisée & Dépend des scripts \\
\hline
\end{tabular}
\caption{Complémentarité Power BI + Python intégré}
\end{table}



\subsection{Valeur Business Générée}

\begin{itemize}
    \item \textbf{Visibilité améliorée} : Surveillance continue des performances commerciales
    \item \textbf{Décision data-driven} : Réduction de l'intuition dans les décisions stratégiques
    \item \textbf{Efficacité opérationnelle} : Identification rapide des problèmes et opportunités
    \item \textbf{Optimisation des ressources} : Allocation ciblée des efforts d'amélioration
    \item \textbf{Fidélisation client} : Approche proactive de la satisfaction client basée sur les données
    \item \textbf{Compétitivité} : Avantage concurrentiel grâce à l'analyse avancée
\end{itemize}

\vspace{1cm}

\begin{center}
\fbox{\parbox{0.8\textwidth}{
\textbf{Conclusion Finale :} \\
Le projet Northwind BI a démontré qu'une approche intégrée Power BI + Python permet de combiner le meilleur des deux mondes : la puissance d'ETL et d'interactivité de Power BI avec la flexibilité analytique de Python directement intégrée dans le dashboard. Les 6 visualisations développées fournissent une vision complète et actionnable des performances commerciales, avec des recommandations concrètes pour l'amélioration continue. Le fichier KPI.csv généré automatiquement ouvre la voie à des analyses plus poussées et à l'intégration dans d'autres systèmes.
}}
\end{center}

\end{document}